# 休眠唤醒机制

|                        | **LP0**                        | **LP1**  | **LP2**                        | **LP3**                 |
| ---------------------- | ------------------------------ | -------- | ------------------------------ | ----------------------- |
| RAM Retention          | On                             | On       | Off                            | Off                     |
| Low Power Clock  (32K) | On                             | Off      | On                             | Off                     |
| Power Consumption      | 12-14uA (64K RAM)              | ≈LP0-1uA | <1uA                           | <500nA                  |
| Scenario               | BLE ADV/CONN                   |          | Wakeup from RTC or IO & Reboot | Wakeup from IO & Reboot |
|                        | Scheduled By SDK Automatically |          | Triggered by APP               | Triggered by APP        |

[^1]: LP1相比LP0，功耗差异不大，且没有典型应用场景



## LP0

LP0通常用于BLE广播和连接状态下降低功耗。BLE广播和连接都是周期性地收发数据，仅仅在收发数据的时间段内，需要系统正常工作，其余时段，除了需要维持协议时序的低速时钟工作外，其余模块均不需要工作。

- Bare-Metal应用，大循环消息队列没有待处理的消息
- RTOS应用，除了Idle任务外，没有其他就绪态的任务

上述两种情况下，系统都会调用休眠检查相关代码，若片上外设均处于空闲状态，且BLE在当前一段时间内没有活动（如收发数据和协议处理），则进入LP0休眠流程。

在BLE应用场景里，工作、空闲状态是周期性交替出现的，在空闲状态下，系统就会启动LP0休眠，这是由SDK软件框架自动完成的，不需要应用层专门调用。

### 外设与LP0

在HAL外设库中，xxx_Init、xxx_DeInit分别会设置、清除标记该外设忙状态的全局变量。所以外设每一段连续工作阶段开始时都应该调用初始化函数，结束时都应该调用相应的反初始化函数，否则外设忙状态会阻止系统进入LP0。但也有一类应用，需要保持外设处于常监听状态，比如串口数据接收和SPI从设备收发，这时相应外设一直处于工作状态，系统不会休眠。需要进入休眠时，应用必须主动结束监听。

LP0模式下，为了避免漏电，IO状态须维持不变。对于使用IO复用功能的外设，需要在外设初始化前，调用对应的外设IO初始化函数（xxx_io_init），在外设反初始化后，调用对应的外设IO反初始化函数（xxx_io_deinit）。外设IO初始化函数会配置IO复用功能，外设IO反初始化函数会关闭IO复用功能，恢复为GPIO，且输入输出状态保持不变。如果外设反初始化后，不进行外设IO反初始化，会造成IO管脚复用状态依然维持，一旦进入LP0后，外设模块掉电，复用状态的IO无法得到正确的输入输出配置，可能产生漏电。

## LP2、LP3

LP2和LP3的特点是RAM不保持。因此唤醒后，无法恢复现场，只能重新执行启动流程。调用进入LP2、LP3的函数后，可认为程序的运行到此结束，直到唤醒条件满足，再重新启动系统。

### LE501X

LE501X进入LP2，LP3后，所有管脚均会变为输入使能状态，而上下拉配置可以维持。为了避免引起PCB上IO漏电，进入LP2、LP3的函数进行了如下配置：

- 所有输出高的IO，配置上拉
- 所有输出低的IO，配置下拉
- 所有输入使能的IO，维持之前的上下拉配置
- 所有输入未使能的IO，配置下拉
