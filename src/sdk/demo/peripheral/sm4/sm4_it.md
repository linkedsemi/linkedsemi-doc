# SM4_IT 使用示例

例程路径： ls_sdk/examples/peripheral/sm4/sm4_it

## 一、程序基本配置及说明：

```c
/*sm4模块初始化*/
HAL_SM4_Init();
```

## 二、操作步骤及结果：

### 2.1	密钥扩展

```c
const uint8_t key[16] = {
    0x01, 0x23, 0x45, 0x67,
    0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98,
    0x76, 0x54, 0x32, 0x10};
void sm4_init(void)
{
    HAL_SM4_Init();
    HAL_SM4_KeyExpansion_IT(key);
    while (flag == SM4_KEYEXPANSEND);
}
void HAL_SM4_KeyExpansion_Complete_Callback()
{
    flag = SM4_ENCRYPT;
    LOG_I("CRYPT_SM4_KeyExpansion_TEST_SUCCESS!");
}
```

在加密和解密之前需要先进行密钥扩展，扩展完成后调用回调函数，修改flag，退出while。

### 2.2	加密测试

```c
uint32_t length = 16;
uint8_t plainbuffer[64];
const uint8_t plaintext[64] = {
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10};
void sm4_crypt_test()
{
    HAL_SM4_Encrypt_IT(plaintext, cipherbuffer, length);
    while (flag == SM4_ENCRYPT);
}
```

- plaintext是待加密的明文地址
- cipherbuffer是加密后密文输出地址
- length是加密的长度，以Byte为单位,例程中进行了长度分别为16、32、64的加密运算

示例开始加密后返回，在while中等待，加密完成后调用回调函数，修改flag，退出while，log如下：

- CRYPT_SM4_ENCRYPT_16_TEST_SUCCESS!
- CRYPT_SM4_ENCRYPT_32_TEST_SUCCESS!
- CRYPT_SM4_ENCRYPT_64_TEST_SUCCESS!

### 2.3	解密测试

```c
uint8_t cipherbuffer[64];
const uint8_t plaintext[64] = {
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67,0x89, 0xab, 0xcd, 0xef,0xfe, 0xdc, 0xba, 0x98,0x76, 0x54, 0x32, 0x10};
void sm4_crypt_test()
{
    HAL_SM4_Decrypt_IT(ciphertext, plainbuffer, length);
    while (flag == SM4_DECRYPT);
}
```

- ciphertext是待解密的密文地址
- plainbuffer是解密后明文输出地址
- length是待解密的密文文长度，以Byte为单位,例程中进行了长度分别为16、32、64的解密运算

示例开始解密后返回，在while中等待，解密完成后调用回调函数，修改flag，退出while，log如下：

- CRYPT_SM4_DECRYPT_16_TEST_SUCCESS!
- CRYPT_SM4_DECRYPT_32_TEST_SUCCESS!
- CRYPT_SM4_DECRYPT_64_TEST_SUCCESS!